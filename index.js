// Generated by CoffeeScript 1.12.2
(function() {
  var BroccoliPug, META_CACHE_NAME, Plugin, Promise, compile, debug, exists, fs, getReferences, lex, makeOutputPath, mkdirp, parse, path, pug, replaceExtension, symlink, walk,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  path = require('path');

  Plugin = require('broccoli-plugin');

  Promise = require('bluebird');

  walk = require('walk-sync');

  mkdirp = require('mkdirp').sync;

  symlink = require('symlink-or-copy').sync;

  fs = Promise.promisifyAll(require('fs'));

  exists = require('file-exists');

  debug = require('debug')('broccoli-pug');

  pug = require('pug');

  lex = require('pug-lexer');

  parse = require('pug-parser');

  replaceExtension = function(file, ext) {
    return file.substr(0, file.lastIndexOf('.')) + ext;
  };

  getReferences = function(node) {
    var child, i, len, ref, refs;
    refs = [];
    if ((node.file != null) && node.file.type === 'FileReference') {
      refs.push(node.file.path);
    }
    if (node.nodes != null) {
      ref = node.nodes;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        refs = refs.concat(getReferences(child));
      }
    }
    return refs;
  };

  compile = function(inputPath, render, options) {
    if (render) {
      return pug.renderFile(inputPath, options);
    } else {
      return 'module.exports=template;' + pug.compileFileClient(inputPath, options);
    }
  };

  makeOutputPath = function(outputPath, render) {
    if (render) {
      return replaceExtension(outputPath, '.html');
    } else {
      return replaceExtension(outputPath, '.js');
    }
  };

  META_CACHE_NAME = '.metacache';

  BroccoliPug = (function(superClass) {
    extend(BroccoliPug, superClass);

    function BroccoliPug(inputNodes, options) {
      if (!(this instanceof BroccoliPug)) {
        return new BroccoliPug(inputNodes, options);
      }
      this.render = (options != null ? options.render : void 0) || false;
      this.pugOptions = (options != null ? options.pugOptions : void 0) || {};
      BroccoliPug.__super__.constructor.call(this, inputNodes, options);
    }

    BroccoliPug.prototype.build = function() {
      var basePath, cachePath, dependency, file, files, filesMap, fullPath, i, inputPath, j, k, len, len1, len2, meta, metaPath, mtime, outputPath, promise, promises, ref, ref1, relativePath, savedMeta, useCache;
      promises = [];
      meta = {};
      metaPath = path.join(this.cachePath, META_CACHE_NAME);
      if (exists(metaPath)) {
        savedMeta = JSON.parse(fs.readFileSync(metaPath, 'utf8'));
      } else {
        savedMeta = {};
      }
      ref = this.inputPaths;
      for (i = 0, len = ref.length; i < len; i++) {
        inputPath = ref[i];
        files = walk.entries(inputPath);
        filesMap = files.reduce(function(acc, file) {
          acc[file.relativePath] = file;
          return acc;
        }, {});
        for (j = 0, len1 = files.length; j < len1; j++) {
          file = files[j];
          if (file.isDirectory()) {
            continue;
          }
          basePath = file.basePath, relativePath = file.relativePath, mtime = file.mtime;
          outputPath = makeOutputPath(path.join(this.outputPath, relativePath), this.render);
          mkdirp(path.dirname(outputPath));
          fullPath = path.join(basePath, relativePath);
          if (path.extname(fullPath) !== '.pug') {
            symlink(fullPath, outputPath);
            continue;
          }
          useCache = true;
          if (savedMeta[relativePath] != null) {
            if (mtime > savedMeta[relativePath].mtime) {
              debug("Rebuilding " + relativePath + " due to changes");
              useCache = false;
            }
            ref1 = savedMeta[relativePath].dependencies;
            for (k = 0, len2 = ref1.length; k < len2; k++) {
              dependency = ref1[k];
              if (filesMap[dependency].mtime > savedMeta[dependency].mtime) {
                debug("Rebuilding " + relativePath + " due to changes in " + dependency);
                useCache = false;
                break;
              }
            }
          } else {
            debug("Initial build of " + relativePath);
            useCache = false;
          }
          cachePath = path.join(this.cachePath, relativePath);
          if (useCache) {
            meta[relativePath] = savedMeta[relativePath];
            if (!exists(outputPath)) {
              symlink(cachePath, outputPath);
            }
            continue;
          }
          mkdirp(path.dirname(cachePath));
          promise = (function(_this) {
            return function(inputPath, fullPath, relativePath, cachePath, outputPath, mtime, meta) {
              return fs.readFileAsync(fullPath, 'utf8').then(function(contents) {
                var ast, compiled, dependencies, tokens;
                tokens = lex(contents, {
                  filename: fullPath
                });
                ast = parse(tokens, {
                  filename: fullPath,
                  src: contents
                });
                console.error(getReferences(ast));
                dependencies = getReferences(ast).map(function(depPath) {
                  var resolved;
                  resolved = path.relative(inputPath, path.join(path.dirname(fullPath), depPath));
                  if (path.extname(resolved) === '') {
                    resolved += '.pug';
                  }
                  return resolved;
                });
                meta[relativePath] = {
                  dependencies: dependencies,
                  mtime: mtime
                };
                compiled = compile(fullPath, _this.render, _this.pugOptions);
                return fs.writeFileAsync(cachePath, compiled).then(function() {
                  return symlink(cachePath, outputPath);
                });
              });
            };
          })(this)(inputPath, fullPath, relativePath, cachePath, outputPath, mtime, meta);
          promises.push(promise);
        }
      }
      return Promise.all(promises).then(function() {
        return fs.writeFileAsync(metaPath, JSON.stringify(meta));
      });
    };

    return BroccoliPug;

  })(Plugin);

  module.exports = BroccoliPug;

}).call(this);
